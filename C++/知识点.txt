####静态成员函数和静态变量
出现在类体外的函数定义不能指定关键字static；
静态成员之间可以相互访问，包括静态成员函数访问静态数据成员和访问静态成员函数；
非静态成员函数可以任意地访问静态成员函数和静态数据成员；
静态成员函数不能访问非静态成员函数和非静态数据成员；
由于没有this指针的额外开销，因此静态成员函数与类的全局函数相比速度上会有少许的增长；
调用静态成员函数，可以用成员访问操作符(.)和(->)为一个类的对象或指向类对象的指针调用静态成员函数，
当同一类的所有对象使用一个量时，对于这个共用的量，可以用静态数据成员变量，这个变量对于同一类的所有的对象都取相同的值。静态成员变量只能被静态成员函数调用。静态成员函数也是由同一类中的所有对象共用。只能调用静态成员变量和静态成员函数。
###C++引用于引用作为函数参数的作用
 &只有在数据类型后&才是引用声明符。
（1）声明一个引用时，必须同时使之初始化，及声明它代表哪一个变量。（有一个例外，引用作为函数参数时，不需要初始化） 
（2）在声明一个引用后，不能再使之作为另一变量的引用。 
（3）不能建立引用数组。 
（4）不能建立引用的引用。
##C++
##堆和栈的区别
堆栈空间分配
栈（操作系统）：由操作系统自动分配释放 ，存放函数的参数值，局部变量的值等。其操作方式类似于数据结构中的栈。
堆（操作系统）： 一般由程序员分配释放， 若程序员不释放，程序结束时可能由OS回收，分配方式倒是类似于链表
堆栈缓存方式
栈使用的是一级缓存， 他们通常都是被调用时处于存储空间中，调用完毕立即释放。
堆则是存放在二级缓存中，生命周期由虚拟机的垃圾回收算法来决定（并不是一旦成为孤儿对象就能被回收）。所以调用这些对象的速度要相对来得低一些。
1、管理方式不同；
2、空间大小不同；
3、能否产生碎片不同；
4、生长方向不同；
5、分配方式不同；
6、分配效率不同；
管理方式：对于栈来讲，是由编译器自动管理，无需我们手工控制；对于堆来说，释放工作由程序员控制，容易产生memory leak。
空间大小：一般来讲在32位系统下，堆内存可以达到4G的空间，从这个角度来看堆内存几乎是没有什么限制的。但是对于栈来讲，一般都是有一定的空间大小的，例如，在VC6下面，默认的栈空间大小是1M（好像是，记不清楚了）。当然，我们可以修改：    
打开工程，依次操作菜单如下：Project->Setting->Link，在Category 中选中Output，然后在Reserve中设定堆栈的最大值和commit。
注意：reserve最小值为4Byte；commit是保留在虚拟内存的页文件里面，它设置的较大会使栈开辟较大的值，可能增加内存的开销和启动时间。
碎 片问题：对于堆来讲，频繁的new/delete势必会造成内存空间的不连续，从而造成大量的碎片，使程序效率降低。对于栈来讲，则不会存在这个问题，因 为栈是先进后出的队列，他们是如此的一一对应，以至于永远都不可能有一个内存块从栈中间弹出，在他弹出之前，在他上面的后进的栈内容已经被弹出，详细的可 以参考数据结构，这里我们就不再一一讨论了。
生长方向：对于堆来讲，生长方向是向上的，也就是向着内存地址增加的方向；对于栈来讲，它的生长方向是向下的，是向着内存地址减小的方向增长。
分配方式：堆都是动态分配的，没有静态分配的堆。栈有2种分配方式：静态分配和动态分配。静态分配是编译器完成的，比如局部变量的分配。动态分配由alloca函数进行分配，但是栈的动态分配和堆是不同的，他的动态分配是由编译器进行释放，无需我们手工实现。
分配效率：栈是机器系统提供的数据结构，计算机会在底层对栈提供支持：分配专门的寄存器存放栈的地址，压栈出栈都有专门的指令执行，这就决定了栈的效率比较 高。堆则是C/C++函数库提供的，它的机制是很复杂的，例如为了分配一块内存，库函数会按照一定的算法（具体的算法可以参考数据结构/操作系统）在堆内 存中搜索可用的足够大小的空间，如果没有足够大小的空间（可能是由于内存碎片太多），就有可能调用系统功能去增加程序数据段的内存空间，这样就有机会分到 足够大小的内存，然后进行返回。显然，堆的效率比栈要低得多。
从这里我们可以看到，堆和栈相比，由于大量new/delete的使用，容 易造成大量的内存碎片；由于没有专门的系统支持，效率很低；由于可能引发用户态和核心态的切换，内存的申请，代价变得更加昂贵。所以栈在程序中是应用最广 泛的，就算是函数的调用也利用栈去完成，函数调用过程中的参数，返回地址，EBP和局部变量都采用栈的方式存放。所以，我们推荐大家尽量用栈，而不是用 堆。
虽然栈有如此众多的好处，但是由于和堆相比不是那么灵活，有时候分配大量的内存空间，还是用堆好一些。
##C++的内存分配是怎么样的？
在C++中，内存分成5个区，他们分别是堆、栈、自由存储区、全局/静态存储区和常量存储区。

栈，在执行函数时，函数内局部变量的存储单元都可以在栈上创建，函数执行结束时这些存储单元自动被释放。栈内存分配运算内置于处理器的指令集中，效率很高，但是分配的内存容量有限。

堆，就是那些由new分配的内存块，他们的释放编译器不去管，由我们的应用程序去控制，一般一个new就要对应一个delete。如果程序员没有释放掉，那么在程序结束后，操作系统会自动回收。

自由存储区，就是那些由malloc等分配的内存块，他和堆是十分相似的，不过它是用free来结束自己的生命的。

全局/静态存储区，全局变量和静态变量被分配到同一块内存中，在以前的C语言中，全局变量又分为初始化的和未初始化的，在C++里面没有这个区分了，他们共同占用同一块内存区。

常量存储区，这是一块比较特殊的存储区，他们里面存放的是常量，不允许修改。
##STL的内存分配和释放的方式
http://www.cnblogs.com/biyeymyhjob/archive/2012/09/12/2674004.html
C++中的string copy函数是怎样的？
http://www.cnblogs.com/qlwy/archive/2012/03/25/2416937.html
##extern 的作用
extern 作用1：声明外部变量
extern 作用2：在C++文件中调用C方式编译的函数
sizeof()类大小，空类大小
http://blog.csdn.net/liu_qiqi/article/details/9344627
##为什么基类的析构函数要声明为虚函数
然，并不是要把所有类的析构函数都写成虚函数。只有当一个类是基类(即希望被继承)的时候才需要声明成虚函数，因为虚函数的作用是实现多态，而多态是建立在继承的基础上。单一类不能把析构函数写成虚函数，因为会产生额外的开销，比如虚表的创建和虚指针的定义。
##C语言中static修饰符的意义
http://www.cnblogs.com/yuqiao/p/5801482.html
在C语言中，static通常有2种含义：1）定义变量的生命周期；2）定义变量或者函数的作用域。

变量的生命周期是指，相对于程序运行的进程生命周期，变量存在的时间段。变量的生命周期由变量的存储类型（位置）决定。因此static的第1种含义也可以理解为，static定义了变量的存储类型（位置）。

C语言中，变量存储位置分为栈、全局静态区、堆。栈用来做函数调用，参数传递等，在程序的运行过程中是操作最频繁的数据区。全局静态区，是变量一直存在于内存中，在程序整个运行过程中不会被销毁。堆，是由操作系统维护的大空间内存伸缩区，进程可以主动向操作系统申请使用堆的存储，在程序运行过程中动态申请。

由static修饰的变量，其存储类型为全局静态区，变量在程序的整个运行过程中不会被销毁，并且只会被初始化1次。
